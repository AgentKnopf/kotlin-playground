package com.coresystems.kotlinpresentation.functions

/**
 * The following compiles pretty much to what you would expect in java: A final class named after this file with an
 * appended "kt" and a static final variable in it.
 */
const val FILE_LEVE_CONSTANT = "Foo"

/**
 * In Kotlin you could just call it with it's name, but in Java a "class" with the name of the file is generated and
 * on that you call the function.
 */
fun packageLevelFunction() = "Top"

/**
 * Illustration of Java/Kotlin interop. More information can be found here:
 * https://kotlinlang.org/docs/reference/java-to-kotlin-interop.html
 *
 * If you're interested in the subtle differences, here is a comparison that decompiles the kotlin code to Java and
 * compares it: https://blog.egorand.me/where-do-i-put-my-constants-in-kotlin/
 */
class ClassWithStaticFields {

    /**
     * A companion object is shared amongst all instances of a class, similar to Java's "static" concept
     */
    companion object {
        /**
         * Using "const" generates Java code that has the outer class, the companion object and in the outer class
         * we have this field here, making the generated companion object useless. Note: const only supports primitives!
         */
        const val CONST_FIELD = 123456

        /*
        The following doesn't compile for two reasons: const only allows primitives and String and secondly we're
        exposing the private class by our field being publicly accessible:
        const val FRUIT_INSTANCE = SomeClass()
         */

        /**
         * From the outside this pretty much works like const, when trying to access it from java, the difference is
         * in the generated bytecode.
         */
        @JvmField
        val JVM_ANNOTATED_FIELD = "Hello World"
    }
}

private class SomeClass

class ClassWithStaticMethod {
    companion object {

        fun somOtherMethod() = "No"

        @JvmStatic
        fun someStaticMethod() = "Hello"
    }
}